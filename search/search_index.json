{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Angular localization \u00b6 An Angular library to translate messages, dates and numbers This library is for localization of Angular v7 apps. It allows, in addition to translation, to localize numbers and dates of your app, adding language code , country code , currency code , timezone and optionally script code , numbering system and calendar , through Internationalization API . It also implements the validation of numbers by locales. Sample app built with Angular CLI & Material, and its source code . Library version: 6.6.1 - Changelog Installing \u00b6 You can add angular-l10n to your project using npm : npm install angular-l10n --save","title":"Home"},{"location":"#angular-localization","text":"An Angular library to translate messages, dates and numbers This library is for localization of Angular v7 apps. It allows, in addition to translation, to localize numbers and dates of your app, adding language code , country code , currency code , timezone and optionally script code , numbering system and calendar , through Internationalization API . It also implements the validation of numbers by locales. Sample app built with Angular CLI & Material, and its source code . Library version: 6.6.1 - Changelog","title":"Angular localization"},{"location":"#installing","text":"You can add angular-l10n to your project using npm : npm install angular-l10n --save","title":"Installing"},{"location":"quick-start/","text":"Quick start \u00b6 First scenario: you only need to translate texts \u00b6 Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` <h1>{{ title }}</h1> <h3>{{ 'Change language' | translate:lang }}</h3> <button (click)=\"selectLanguage('en');\">English</button> <button (click)=\"selectLanguage('it');\">Italiano</button> <app-home></app-home> ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } selectLanguage(language: string): void { this.locale.setCurrentLanguage(language); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` <p>{{ 'Greeting' | translate:lang }}</p> <p title=\"{{ 'Greeting' | translate:lang }}\">{{ 'Subtitle' | translate:lang }}</p> ` }) export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { \"Title\": \"Angular localization\", \"Subtitle\": \"It's a small world\", \"Change language\": \"Change language\", \"Greeting\": \"Hi!\" } { \"Title\": \"Localizzazione in Angular\", \"Subtitle\": \"Il mondo \u00e8 piccolo\", \"Change language\": \"Cambia lingua\", \"Greeting\": \"Ciao!\" } Using directives \u00b6 In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component } from '@angular/core'; @Component({ selector: 'app-home', template: ` <p l10nTranslate>Greeting</p> <p l10n-title title=\"Greeting\" l10nTranslate>Subtitle</p> ` }) export class HomeComponent { } Note that if you use in the component only the directives and not the pipes , you don't need to use @Language() decorator . Second scenario: you need to translate texts, dates & numbers \u00b6 Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, LocalizationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` <h1>{{ title }}</h1> <h3>{{ 'Change country' | translate:lang }}</h3> <button (click)=\"selectLocale('en', 'US', 'USD');\">United States</button> <button (click)=\"selectLocale('en', 'GB', 'GBP');\">United Kingdom</button> <button (click)=\"selectLocale('it', 'IT', 'EUR');\">Italia</button> <app-home></app-home> ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } selectLocale(language: string, country: string, currency: string): void { this.locale.setDefaultLocale(language, country); this.locale.setCurrentCurrency(currency); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language, DefaultLocale, Currency } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` <p>{{ 'Greeting' | translate:lang }}</p> <p title=\"{{ 'Greeting' | translate:lang }}\">{{ 'Subtitle' | translate:lang }}</p> <p>{{ today | l10nDate:defaultLocale:'fullDate' }}</p> <p>{{ pi | l10nDecimal:defaultLocale:'1.5-5' }}</p> <p>{{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }}</p> <button (click)=\"change()\">{{ 'Change' | translate:lang }}</button> ` }) export class HomeComponent implements OnInit { @Language() lang: string; @DefaultLocale() defaultLocale: string; @Currency() currency: string; today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { \"Title\": \"Angular localization\", \"Subtitle\": \"It's a small world\", \"Change country\": \"Change country\", \"Greeting\": \"Hi!\", \"Change\": \"Change\" } { \"Title\": \"Localizzazione in Angular\", \"Subtitle\": \"Il mondo \u00e8 piccolo\", \"Change country\": \"Cambia Paese\", \"Greeting\": \"Ciao!\", \"Change\": \"Cambia\" } Finally, to extend the support to old browsers, add the following script tag in index.html : <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US,Intl.~locale.en-GB,Intl.~locale.it-IT\"></script> Using directives \u00b6 In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-home', template: ` <p l10nTranslate>Greeting</p> <p l10n-title title=\"Greeting\" l10nTranslate>Subtitle</p> <p format=\"fullDate\" l10nDate>{{ today }}</p> <p digits=\"1.5-5\" l10nDecimal>{{ pi }}</p> <p digits=\"1.2-2\" currencyDisplay=\"symbol\" l10nCurrency>{{ value }}</p> <button (click)=\"change()\" l10nTranslate>Change</button> ` }) export class HomeComponent implements OnInit { today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } Note that if you use in the component only the directives and not the pipes , you don't need to use decorators . Advanced initialization \u00b6 If you want the app to be rendered only after the translation file is loaded, you can use these settings in app.module.ts : import { NgModule, APP_INITIALIZER } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; // Advanced initialization. export function initL10n(l10nLoader: L10nLoader): Function { return () => l10nLoader.load(); } // APP_INITIALIZER will execute the function when the app is initialized and delay what it provides. @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], providers: [ { provide: APP_INITIALIZER, useFactory: initL10n, deps: [L10nLoader], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Appendix A - Using Angular CLI \u00b6 If you are using Angular CLI , you have to add the json files in src/assets folder, copied as-is when building your project. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix B - Using Ionic \u00b6 You have to add the json files in www/assets folder. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix C - Using Angular Meteor \u00b6 You must create public/assets folder at the root of your app. In this way, assets folder is copied directly into your application bundle. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix D - Using Angular Universal \u00b6 There are two ways: Prerender (prerender) \u00b6 Happens at build time. Renders your application and replaces the dist index.html with a version rendered at the route / . Server-Side Rendering (ssr) \u00b6 Happens at runtime. Uses a server Engine to render you application on the fly at the requested url. Note This library builds only one app, and not an app for each language as Angular i18n native solution: so your prerendered index.html will contain the translation according to the language defined during the configuration. If you use Direct loading , there are no particular warnings. If you use Asynchronous loading , you have to solve the problem of http requests during prerender or ssr : About prerender : you need to provide absolute URLs to a running server that will be the same that will serve the data (or through a proxy): if this is not possible and you want to use the prerender instead of ssr , you should use Angular i18n native solution. About ssr : you only need to use absolute URLs , so for example: ... providers: [ { type: ProviderType.Static, prefix: 'http:localhost:4000/assets/locale-' } ], ... Please note that problems with http requests are not due to this library, but to common questions about http requests in Universal apps. The following is an example that uses Asynchronous loading , based on Angular Universal Starter : app.module.ts : const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [], caching: true } }; @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig, @Inject(PLATFORM_ID) private platformId: Object ) { } load(): Promise<void> { if (isPlatformBrowser(this.platformId)) { // Client only code. this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; } if (isPlatformServer(this.platformId)) { // Server only code. this.translationConfig.providers = [ { type: ProviderType.Static, prefix: 'http://localhost:4000/assets/locale-' } ]; } return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () => localizationConfig.load(); } @NgModule({ ... imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], providers: [ LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Now, depending on whether you want to use the prerender or ssr in production, you must proceed as follows: prerender npm run build:ssr npm run serve:ssr The server is ready, so you can generate the pre-built files. Open a new terminal and type: npm run generate:prerender If you see in the dist/browser folder, your html files should have the translated values (in the default language). To test it: npm run serve:prerender ssr npm run build:ssr npm run serve:ssr","title":"Quick start"},{"location":"quick-start/#quick-start","text":"","title":"Quick start"},{"location":"quick-start/#first-scenario-you-only-need-to-translate-texts","text":"Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` <h1>{{ title }}</h1> <h3>{{ 'Change language' | translate:lang }}</h3> <button (click)=\"selectLanguage('en');\">English</button> <button (click)=\"selectLanguage('it');\">Italiano</button> <app-home></app-home> ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } selectLanguage(language: string): void { this.locale.setCurrentLanguage(language); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` <p>{{ 'Greeting' | translate:lang }}</p> <p title=\"{{ 'Greeting' | translate:lang }}\">{{ 'Subtitle' | translate:lang }}</p> ` }) export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { \"Title\": \"Angular localization\", \"Subtitle\": \"It's a small world\", \"Change language\": \"Change language\", \"Greeting\": \"Hi!\" } { \"Title\": \"Localizzazione in Angular\", \"Subtitle\": \"Il mondo \u00e8 piccolo\", \"Change language\": \"Cambia lingua\", \"Greeting\": \"Ciao!\" }","title":"First scenario: you only need to translate texts"},{"location":"quick-start/#using-directives","text":"In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component } from '@angular/core'; @Component({ selector: 'app-home', template: ` <p l10nTranslate>Greeting</p> <p l10n-title title=\"Greeting\" l10nTranslate>Subtitle</p> ` }) export class HomeComponent { } Note that if you use in the component only the directives and not the pipes , you don't need to use @Language() decorator .","title":"Using directives"},{"location":"quick-start/#second-scenario-you-need-to-translate-texts-dates-numbers","text":"Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, LocalizationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` <h1>{{ title }}</h1> <h3>{{ 'Change country' | translate:lang }}</h3> <button (click)=\"selectLocale('en', 'US', 'USD');\">United States</button> <button (click)=\"selectLocale('en', 'GB', 'GBP');\">United Kingdom</button> <button (click)=\"selectLocale('it', 'IT', 'EUR');\">Italia</button> <app-home></app-home> ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } selectLocale(language: string, country: string, currency: string): void { this.locale.setDefaultLocale(language, country); this.locale.setCurrentCurrency(currency); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language, DefaultLocale, Currency } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` <p>{{ 'Greeting' | translate:lang }}</p> <p title=\"{{ 'Greeting' | translate:lang }}\">{{ 'Subtitle' | translate:lang }}</p> <p>{{ today | l10nDate:defaultLocale:'fullDate' }}</p> <p>{{ pi | l10nDecimal:defaultLocale:'1.5-5' }}</p> <p>{{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }}</p> <button (click)=\"change()\">{{ 'Change' | translate:lang }}</button> ` }) export class HomeComponent implements OnInit { @Language() lang: string; @DefaultLocale() defaultLocale: string; @Currency() currency: string; today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { \"Title\": \"Angular localization\", \"Subtitle\": \"It's a small world\", \"Change country\": \"Change country\", \"Greeting\": \"Hi!\", \"Change\": \"Change\" } { \"Title\": \"Localizzazione in Angular\", \"Subtitle\": \"Il mondo \u00e8 piccolo\", \"Change country\": \"Cambia Paese\", \"Greeting\": \"Ciao!\", \"Change\": \"Cambia\" } Finally, to extend the support to old browsers, add the following script tag in index.html : <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US,Intl.~locale.en-GB,Intl.~locale.it-IT\"></script>","title":"Second scenario: you need to translate texts, dates &amp; numbers"},{"location":"quick-start/#using-directives_1","text":"In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-home', template: ` <p l10nTranslate>Greeting</p> <p l10n-title title=\"Greeting\" l10nTranslate>Subtitle</p> <p format=\"fullDate\" l10nDate>{{ today }}</p> <p digits=\"1.5-5\" l10nDecimal>{{ pi }}</p> <p digits=\"1.2-2\" currencyDisplay=\"symbol\" l10nCurrency>{{ value }}</p> <button (click)=\"change()\" l10nTranslate>Change</button> ` }) export class HomeComponent implements OnInit { today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } Note that if you use in the component only the directives and not the pipes , you don't need to use decorators .","title":"Using directives"},{"location":"quick-start/#advanced-initialization","text":"If you want the app to be rendered only after the translation file is loaded, you can use these settings in app.module.ts : import { NgModule, APP_INITIALIZER } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType } from 'angular-l10n'; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; // Advanced initialization. export function initL10n(l10nLoader: L10nLoader): Function { return () => l10nLoader.load(); } // APP_INITIALIZER will execute the function when the app is initialized and delay what it provides. @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], providers: [ { provide: APP_INITIALIZER, useFactory: initL10n, deps: [L10nLoader], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { }","title":"Advanced initialization"},{"location":"quick-start/#appendix-a-using-angular-cli","text":"If you are using Angular CLI , you have to add the json files in src/assets folder, copied as-is when building your project. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix A - Using Angular CLI"},{"location":"quick-start/#appendix-b-using-ionic","text":"You have to add the json files in www/assets folder. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix B - Using Ionic"},{"location":"quick-start/#appendix-c-using-angular-meteor","text":"You must create public/assets folder at the root of your app. In this way, assets folder is copied directly into your application bundle. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix C - Using Angular Meteor"},{"location":"quick-start/#appendix-d-using-angular-universal","text":"There are two ways:","title":"Appendix D - Using Angular Universal"},{"location":"quick-start/#prerender-prerender","text":"Happens at build time. Renders your application and replaces the dist index.html with a version rendered at the route / .","title":"Prerender (prerender)"},{"location":"quick-start/#server-side-rendering-ssr","text":"Happens at runtime. Uses a server Engine to render you application on the fly at the requested url. Note This library builds only one app, and not an app for each language as Angular i18n native solution: so your prerendered index.html will contain the translation according to the language defined during the configuration. If you use Direct loading , there are no particular warnings. If you use Asynchronous loading , you have to solve the problem of http requests during prerender or ssr : About prerender : you need to provide absolute URLs to a running server that will be the same that will serve the data (or through a proxy): if this is not possible and you want to use the prerender instead of ssr , you should use Angular i18n native solution. About ssr : you only need to use absolute URLs , so for example: ... providers: [ { type: ProviderType.Static, prefix: 'http:localhost:4000/assets/locale-' } ], ... Please note that problems with http requests are not due to this library, but to common questions about http requests in Universal apps. The following is an example that uses Asynchronous loading , based on Angular Universal Starter : app.module.ts : const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [], caching: true } }; @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig, @Inject(PLATFORM_ID) private platformId: Object ) { } load(): Promise<void> { if (isPlatformBrowser(this.platformId)) { // Client only code. this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; } if (isPlatformServer(this.platformId)) { // Server only code. this.translationConfig.providers = [ { type: ProviderType.Static, prefix: 'http://localhost:4000/assets/locale-' } ]; } return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () => localizationConfig.load(); } @NgModule({ ... imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], providers: [ LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Now, depending on whether you want to use the prerender or ssr in production, you must proceed as follows: prerender npm run build:ssr npm run serve:ssr The server is ready, so you can generate the pre-built files. Open a new terminal and type: npm run generate:prerender If you see in the dist/browser folder, your html files should have the translated values (in the default language). To test it: npm run serve:prerender ssr npm run build:ssr npm run serve:ssr","title":"Server-Side Rendering (ssr)"},{"location":"spec/api/","text":"Services APIs \u00b6 TranslationModule \u00b6 Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<TranslationModule> Use in AppModule : new instances of LocaleService & TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<TranslationModule> Use in feature modules with lazy loading: new instance of TranslationService LocalizationModule \u00b6 Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<LocalizationModule> Use in AppModule : new instances of LocaleService & TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<LocalizationModule> Use in feature modules with lazy loading: new instance of TranslationService LocaleValidationModule \u00b6 Method Function static forRoot(): ModuleWithProviders<LocaleValidationModule> Use in AppModule : new instance of LocaleValidation L10nLoader \u00b6 Method Function load(): Promise<any> Loads l10n services ILocaleService \u00b6 Property Value languageCodeChanged: EventEmitter<string> defaultLocaleChanged: EventEmitter<string> currencyCodeChanged: EventEmitter<string> timezoneChanged: EventEmitter<string> loadTranslation: Subject<any> currencyCode: string timezone: string Method Function getConfiguration(): LocaleConfig init(): Promise<void> getBrowserLanguage(): string | null getAvailableLanguages(): string[] getLanguageDirection(languageCode?: string): string getCurrentLanguage(): string getCurrentCountry(): string getCurrentScript(): string getCurrentLocale(): string Returns the well formatted locale as {languageCode}[-scriptCode][-countryCode] getCurrentNumberingSystem(): string getCurrentCalendar(): string getDefaultLocale(): string getCurrentCurrency(): string getCurrencySymbol(currencyDisplay?: 'code' | 'symbol' | 'name', defaultLocale?: string, currency?: string): string getCurrentTimezone(): string setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void composeLocale(codes: ISOCode[]): string rollback(): void ITranslationService \u00b6 Property Value translationError: Subject<any> Fired when the translation data could not been loaded. Returns the error Method Function getConfiguration(): TranslationConfig init(): Promise<any> translationChanged(): Observable<string> Fired when the translation data has been loaded. Returns the translation language translate(keys: string | string[], args?: any, lang?: string): string | any Translates a key or an array of keys translateAsync(keys: string | string[], args?: any, lang?: string): Observable<string | any> ILocaleValidation \u00b6 Method Function parseNumber(s: string, defaultLocale?: string): number | null Converts a string to a number according to default locale. If the string cannot be converted to a number, returns NaN getRegExp(digits: string, defaultLocale?: string): RegExp ICollator \u00b6 Method Function compare(key1: string, key2: string, extension?: string, options?: any): number Compares two keys by the value of translation according to the current language sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] Sorts an array of objects or an array of arrays according to the current language sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable<any[]> Sorts asynchronously an array of objects or an array of arrays according to the current language search(s: string, list: any[], keyNames: any[], options?: any): any[] Matches a string into an array of objects or an array of arrays according to the current language searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable<any[]> Matches asynchronously a string into an array of objects or an array of arrays according to the current language IntlAPI \u00b6 Method Function static hasIntl(): boolean static hasDateTimeFormat(): boolean static hasTimezone(): boolean static hasNumberFormat(): boolean static hasCollator(): boolean LocaleStorage \u00b6 Method Function abstract read(name: string): Promise<string | null> This method must contain the logic to read the storage abstract write(name: string, value: string): Promise<void> This method must contain the logic to write the storage TranslationProvider \u00b6 Method Function abstract getTranslation(language: string, args: any): Observable<any> This method must contain the logic of data access TranslationHandler \u00b6 Method Function abstract parseValue(path: string, key: string, value: string | null, args: any, lang: string): string This method must contain the logic to parse the translated value","title":"Services APIs"},{"location":"spec/api/#services-apis","text":"","title":"Services APIs"},{"location":"spec/api/#translationmodule","text":"Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<TranslationModule> Use in AppModule : new instances of LocaleService & TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<TranslationModule> Use in feature modules with lazy loading: new instance of TranslationService","title":"TranslationModule"},{"location":"spec/api/#localizationmodule","text":"Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<LocalizationModule> Use in AppModule : new instances of LocaleService & TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders<LocalizationModule> Use in feature modules with lazy loading: new instance of TranslationService","title":"LocalizationModule"},{"location":"spec/api/#localevalidationmodule","text":"Method Function static forRoot(): ModuleWithProviders<LocaleValidationModule> Use in AppModule : new instance of LocaleValidation","title":"LocaleValidationModule"},{"location":"spec/api/#l10nloader","text":"Method Function load(): Promise<any> Loads l10n services","title":"L10nLoader"},{"location":"spec/api/#ilocaleservice","text":"Property Value languageCodeChanged: EventEmitter<string> defaultLocaleChanged: EventEmitter<string> currencyCodeChanged: EventEmitter<string> timezoneChanged: EventEmitter<string> loadTranslation: Subject<any> currencyCode: string timezone: string Method Function getConfiguration(): LocaleConfig init(): Promise<void> getBrowserLanguage(): string | null getAvailableLanguages(): string[] getLanguageDirection(languageCode?: string): string getCurrentLanguage(): string getCurrentCountry(): string getCurrentScript(): string getCurrentLocale(): string Returns the well formatted locale as {languageCode}[-scriptCode][-countryCode] getCurrentNumberingSystem(): string getCurrentCalendar(): string getDefaultLocale(): string getCurrentCurrency(): string getCurrencySymbol(currencyDisplay?: 'code' | 'symbol' | 'name', defaultLocale?: string, currency?: string): string getCurrentTimezone(): string setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void composeLocale(codes: ISOCode[]): string rollback(): void","title":"ILocaleService"},{"location":"spec/api/#itranslationservice","text":"Property Value translationError: Subject<any> Fired when the translation data could not been loaded. Returns the error Method Function getConfiguration(): TranslationConfig init(): Promise<any> translationChanged(): Observable<string> Fired when the translation data has been loaded. Returns the translation language translate(keys: string | string[], args?: any, lang?: string): string | any Translates a key or an array of keys translateAsync(keys: string | string[], args?: any, lang?: string): Observable<string | any>","title":"ITranslationService"},{"location":"spec/api/#ilocalevalidation","text":"Method Function parseNumber(s: string, defaultLocale?: string): number | null Converts a string to a number according to default locale. If the string cannot be converted to a number, returns NaN getRegExp(digits: string, defaultLocale?: string): RegExp","title":"ILocaleValidation"},{"location":"spec/api/#icollator","text":"Method Function compare(key1: string, key2: string, extension?: string, options?: any): number Compares two keys by the value of translation according to the current language sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] Sorts an array of objects or an array of arrays according to the current language sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable<any[]> Sorts asynchronously an array of objects or an array of arrays according to the current language search(s: string, list: any[], keyNames: any[], options?: any): any[] Matches a string into an array of objects or an array of arrays according to the current language searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable<any[]> Matches asynchronously a string into an array of objects or an array of arrays according to the current language","title":"ICollator"},{"location":"spec/api/#intlapi","text":"Method Function static hasIntl(): boolean static hasDateTimeFormat(): boolean static hasTimezone(): boolean static hasNumberFormat(): boolean static hasCollator(): boolean","title":"IntlAPI"},{"location":"spec/api/#localestorage","text":"Method Function abstract read(name: string): Promise<string | null> This method must contain the logic to read the storage abstract write(name: string, value: string): Promise<void> This method must contain the logic to write the storage","title":"LocaleStorage"},{"location":"spec/api/#translationprovider","text":"Method Function abstract getTranslation(language: string, args: any): Observable<any> This method must contain the logic of data access","title":"TranslationProvider"},{"location":"spec/api/#translationhandler","text":"Method Function abstract parseValue(path: string, key: string, value: string | null, args: any, lang: string): string This method must contain the logic to parse the translated value","title":"TranslationHandler"},{"location":"spec/collator/","text":"Collator \u00b6 Import the module: @NgModule({ imports: [ ... CollatorModule // New instance of Collator. ], declarations: [ListComponent] }) export class ListModule { } Collator class has the following methods for sorting and filtering a list by locales: sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable<any[]> search(s: string, list: any[], keyNames: any[], options?: any): any[] searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable<any[]> These methods use the Intl.Collator object, a constructor for collators, objects that enable language sensitive string comparison.","title":"Collator"},{"location":"spec/collator/#collator","text":"Import the module: @NgModule({ imports: [ ... CollatorModule // New instance of Collator. ], declarations: [ListComponent] }) export class ListModule { } Collator class has the following methods for sorting and filtering a list by locales: sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable<any[]> search(s: string, list: any[], keyNames: any[], options?: any): any[] searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable<any[]> These methods use the Intl.Collator object, a constructor for collators, objects that enable language sensitive string comparison.","title":"Collator"},{"location":"spec/configuration/","text":"Configuration \u00b6 Loading \u00b6 Angular CLI \u00b6 No need to set up anything, just import it in your code. Rollup or webpack \u00b6 No need to set up anything, just import it in your code. Using SystemJS configuration \u00b6 System.config({ map: { 'angular-l10n': 'node_modules/angular-l10n/bundles/angular-l10n.umd.js' } }); Plain JavaScript \u00b6 If you build apps in Angular using ES5, you can include the umd bundle in your index.html : <script src=\"node_modules/angular-l10n/bundles/angular-l10n.umd.js\"></script> and use global ng.l10n namespace. First scenario: you only need to translate messages \u00b6 Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Second scenario: you need to translate messages, dates & numbers \u00b6 Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Configuration settings \u00b6 The L10nConfig interface contains an interface to configure LocaleService and one to configure TranslationService . LocaleConfig \u00b6 Property Value languages?: Language[] Adds the languages to use in the app language?: string Defines the language ISO 639 two-letter or three-letter code to be used, if the language is not found in the browser defaultLocale?: DefaultLocaleCodes Defines the default locale to be used, regardless of the browser language currency?: string Defines the currency ISO 4217 three-letter code to be used timezone?: string The time zone name of the IANA time zone database to use storage?: StorageStrategy Defines the storage to be used for language, default locale & currency cookieExpiration?: number If the cookie expiration is omitted, the cookie becomes a session cookie localizedRouting?: ISOCode[] Enables localized routing with the provided ISO codes localizedRoutingOptions?: LocalizedRoutingOptions Options for localized routing localeInterceptor?: ISOCode[] Provides ISO codes to locale interceptor TranslationConfig \u00b6 Property Value translationData?: Array<{ languageCode: string; data: any; }> Direct loading: adds translation data providers?: any[] Asynchronous loading: adds translation providers caching?: Boolean Asynchronous loading: disables/enables the cache for translation providers. Provide it only at the root level version?: string Asynchronous loading: adds the query parameter ver to the http requests. Provide it only at the root level timeout?: number Asynchronous loading: sets a timeout in milliseconds for the http requests. Provide it only at the root level rollbackOnError?: boolean Asynchronous loading: rollbacks to previous default locale, currency and timezone on error composedLanguage?: ISOCode[] Sets a composed language for translations missingValue?: string | ((path: string) => string) Sets the value or the function to use for missing keys. Provide it only at the root level missingKey?: string Sets the key to use for missing keys composedKeySeparator?: string Sets composed key separator i18nPlural?: boolean Disables/enables the translation of numbers that are contained at the beginning of the keys There aren't default values: you must explicitly set each parameter you need. Dynamic settings \u00b6 The configuration settings are stored in the following InjectionToken : Interface Token LocaleConfig LOCALE_CONFIG TranslationConfig TRANSLATION_CONFIG If you need to load the configuration data dynamically, you can provide a partial or empty L10nConfig in AppModule , and then update the tokens in your class: const l10nConfig: L10nConfig = { ... translation: { providers: [], // Not available here. caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], ... }) export class AppModule { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig ) { this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; this.l10nLoader.load(); } } Configuration must be completed before invoking the load method of L10nLoader . Or whether you use the advanced initialization : @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig ) { } load(): Promise<void> { this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () => localizationConfig.load(); } @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], providers: [ ... LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], ... }) export class AppModule { } Loading the translation data \u00b6 Direct loading \u00b6 You can use translationData setting when you configure the service, adding all the translation data: const translationEN: any = { Title: \"Angular localization\" }; const translationIT: any = { Title: \"Localizzazione in Angular\" }; const l10nConfig: L10nConfig = { ... translation: { translationData: [ { languageCode: 'en', data: translationEN }, { languageCode: 'it', data: translationIT } ] } }; Asynchronous loading of json files \u00b6 You can add all the providers you need: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ] } }; You can use Direct and Asynchronous loading at the same time. Translation data of Direct loading will be merged before the data of Asynchronous loading. Asynchronous loading through a Web API \u00b6 You can also load the data through a Web API: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.WebAPI, path: 'http://localhost:54703/api/values/' } ] } }; ... export class AppModule { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) => { if (error) { console.log(error); } }); } } [path]{languageCode} will be the URL used by the Http GET requests. So the example URI will be something like: http://localhost:54703/api/values/en . Using fallback providers \u00b6 if you need a cascade fallback when the key is not found, you can use fallback providers: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Fallback, prefix: './assets/global', fallbackLanguage: [] }, { type: ProviderType.Fallback, prefix: './assets/locale-', fallbackLanguage: [ISOCode.Language] }, { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; and create the json files such as global.json , locale-en.json , locale-en-US.json . When you set a fallback provider, the translation data will be merged in order : if a key is found in the en-US file, it is used, otherwise the key in en file and finally the key in global file. Using a custom provider \u00b6 If you need, you can create a custom provider to load translation data. Implement TranslationProvider class-interface and the getTranslation method with the logic to retrieve the data: @Injectable() export class CustomTranslationProvider implements TranslationProvider { /** * This method must contain the logic of data access. * @param language The current language * @param args The object set during the configuration of 'providers' * @return An observable of an object of translation data: {key: value} */ public getTranslation(language: string, args: any): Observable<any> { ... return ... } } Note that the method must return an observable of an object . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationProvider: CustomTranslationProvider } ) ], ... }) See also TranslationProvider code. Caching \u00b6 You can enable the cache during configuration: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true } }; The next time a translation file will be required, will be taken from the cache without making a new http request , with a significant performance improvement: if the user returns to a language already selected; if you use a global file shared across lazy loaded modules . Error handling of data loading \u00b6 To find out if an error occurred during asynchronous loading of translation data, you have the translationError event: ... export class AppComponent { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) => { if (error) { console.log(error); } }); } } If the error occurs on the first loading of the application or a lazy loaded module, you can catch it with the load method: export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load() .catch(err => console.error(err)); } } If you use advanced initialization , you can catch it with the bootstrapModule method in main.ts . Rollback on errror \u00b6 If the error occurs when the user changes language, you can enable rollbackOnError option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... rollbackOnError: true } }; In this way, the application will keep the previous locatization without changing settings. Using a composed language \u00b6 By default, the languageCode is added as extension to the translation files. If you set composedLanguage during the configuration, the combination of supplied codes will be used as language: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' } }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; Your json files should be something like: ./assets/locale-en-US.json and so on. The available ISO codes are: language , country , script . Note that you have to configure defaultLocale and not only language . You must also use setDefaultLocale when the language changes. Default locale, currency & timezone \u00b6 The default locale contains the current language and culture. It consists of: language code : ISO 639 two-letter or three-letter code of the language country code : ISO 3166 two-letter, uppercase code of the country and optionally: script code : used to indicate the script or writing system variations that distinguish the written forms of a language or its dialects. It consists of four letters and was defined according to the assignments found in ISO 15924 numbering system : possible values include: arab , arabext , bali , beng , deva , fullwide , gujr , guru , hanidec , khmr , knda , laoo , latn , limb , mlym , mong , mymr , orya , tamldec , telu , thai , tibt calendar : possible values include: buddhist , chinese , coptic , ethioaa , ethiopic , gregory , hebrew , indian , islamic , islamicc , iso8601 , japanese , persian , roc The currency contains the ISO 4217 currency codes. The timezone contains the time zone names of the IANA time zone database. For more information see Intl API . Storage \u00b6 The defaultLocale , the currency and the timezone chosen by the user are stored, and retrieved at the next access. During the configuration, you can choose your StorageStrategy : Session , Local , Cookie , Disabled . If you don't provide a different expiration using cookieExpiration , the cookie becomes a session cookie. You can also create a custom storage. Implement LocaleStorage class-interface and the read and write methods: @Injectable() export class CustomStorage implements LocaleStorage { /** * This method must contain the logic to read the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @return A promise with the value of the given name */ public async read(name: string): Promise<string | null> { ... return ... } /** * This method must contain the logic to write the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @param value The value for the given name */ public async write(name: string, value: string): Promise<void> { ... } } Note that the read method must return a promise . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { localeStorage: CustomStorage } ) ], ... }) See also LocaleStorage code. Getting browser language \u00b6 Depending on the configuration, the library will automatically try to get the language from the browser or not: If you set language the library tries to get the language from the storage or tries to get the language from the browser or uses the language set in the configuration If you set defaultLocale the library tries to get the defaultLocale from the storage or uses the defaultLocale set in the configuration That's because not all browsers return languageCode-countryCode . Intl API \u00b6 To localize dates and numbers , this library uses the Intl API . Check the current browser support: ECMAScript compatibility tables Can I use All modern browsers have implemented this API. You can use Intl.js to extend support to old browsers. Just add one script tag in your index.html : <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US\"></script> When specifying the features , you have to specify what locale, or locales to load. The timezone is also provided via Intl API . Except IE, all modern browsers have implemented the timezone. To extend the support, you can use Intl.DateTimeFormat timezone polyfill . When a feature is not supported, however, for example in older browsers, Angular localization does not generate an error in the browser, but returns the value without performing operations. Localized routing for SEO \u00b6 In locale-adaptive apps (like the apps that use this library, that return different content based on the preferred locale of the visitor), Google might not crawl, index, or rank all the content for different locales . To solve this problem, you can enable localized routing during configuration: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] }, ... }; Features: A prefix is added to the path of each navigation, containing the language or the locale, creating a semantic URL: baseHref[language[-script][-country]]path https://example.com/en/home https://example.com/en-US/home If the localized link is called, the content is automatically translated. When the language changes, the link is also updated. Changes to localized links do not change browser history. It works also with SSR. To achieve this, the router configuration in your app is not rewritten (operation that would poor performance and could cause errors): the Location class provided by Angular is used for the replacement of the URL, in order to provide the different contents localized both to the crawlers and to the users that can refer to the localized links. Since the link contains only the locale, if your app also uses numbering system , calendar , currency or timezone , you should set schema option below. Using hreflang and sitemap \u00b6 You can use the Sitemap to tell Google all of the locale variants for each URL: <?xml version=\"1.0\" encoding=\"utf-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"> <url> <loc>https://example.com/en/home</loc> <xhtml:link rel=\"alternate\" hreflang=\"it\" href=\"https://example.com/en/home\"/> <xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/it/home\"/> ... <xhtml:link rel=\"alternate\" hreflang=\"x-default\" href=\"https://example.com/home\"/> </url> <url> <loc>https://example.com/it/home</loc> ... </url> ... </urlset> For more info, visit Search Console Help - International Options \u00b6 Default routing \u00b6 If you don't want a localized routing for default language or locale, you can enable it during the configuration: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], localizedRoutingOptions: { defaultRouting: true } }, ... }; Schema \u00b6 If your app uses numbering system , calendar , currency or timezone , it is recommended to provide the schema option, to manage the localized links and refreshes: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], localizedRoutingOptions: { schema: [ { text: 'United States', languageCode: 'en', countryCode: 'US', currency: 'USD' }, { text: 'Italia', languageCode: 'it', countryCode: 'IT', currency: 'EUR' }, ] } }, ... }; Setting the locale in Accept-Language header on outgoing requests \u00b6 To set the locale in Accept-Language header on all outgoing requests, provide the localeInterceptor option during the configuration: const l10nConfig: L10nConfig = { locale: { ... localeInterceptor: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] }, ... }; Then import the module: @NgModule({ imports: [ ... LocaleInterceptorModule ], ... }) export class AppModule { }","title":"Configuration"},{"location":"spec/configuration/#configuration","text":"","title":"Configuration"},{"location":"spec/configuration/#loading","text":"","title":"Loading"},{"location":"spec/configuration/#angular-cli","text":"No need to set up anything, just import it in your code.","title":"Angular CLI"},{"location":"spec/configuration/#rollup-or-webpack","text":"No need to set up anything, just import it in your code.","title":"Rollup or webpack"},{"location":"spec/configuration/#using-systemjs-configuration","text":"System.config({ map: { 'angular-l10n': 'node_modules/angular-l10n/bundles/angular-l10n.umd.js' } });","title":"Using SystemJS configuration"},{"location":"spec/configuration/#plain-javascript","text":"If you build apps in Angular using ES5, you can include the umd bundle in your index.html : <script src=\"node_modules/angular-l10n/bundles/angular-l10n.umd.js\"></script> and use global ng.l10n namespace.","title":"Plain JavaScript"},{"location":"spec/configuration/#first-scenario-you-only-need-to-translate-messages","text":"Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } }","title":"First scenario: you only need to translate messages"},{"location":"spec/configuration/#second-scenario-you-need-to-translate-messages-dates-numbers","text":"Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } }","title":"Second scenario: you need to translate messages, dates &amp; numbers"},{"location":"spec/configuration/#configuration-settings","text":"The L10nConfig interface contains an interface to configure LocaleService and one to configure TranslationService .","title":"Configuration settings"},{"location":"spec/configuration/#localeconfig","text":"Property Value languages?: Language[] Adds the languages to use in the app language?: string Defines the language ISO 639 two-letter or three-letter code to be used, if the language is not found in the browser defaultLocale?: DefaultLocaleCodes Defines the default locale to be used, regardless of the browser language currency?: string Defines the currency ISO 4217 three-letter code to be used timezone?: string The time zone name of the IANA time zone database to use storage?: StorageStrategy Defines the storage to be used for language, default locale & currency cookieExpiration?: number If the cookie expiration is omitted, the cookie becomes a session cookie localizedRouting?: ISOCode[] Enables localized routing with the provided ISO codes localizedRoutingOptions?: LocalizedRoutingOptions Options for localized routing localeInterceptor?: ISOCode[] Provides ISO codes to locale interceptor","title":"LocaleConfig"},{"location":"spec/configuration/#translationconfig","text":"Property Value translationData?: Array<{ languageCode: string; data: any; }> Direct loading: adds translation data providers?: any[] Asynchronous loading: adds translation providers caching?: Boolean Asynchronous loading: disables/enables the cache for translation providers. Provide it only at the root level version?: string Asynchronous loading: adds the query parameter ver to the http requests. Provide it only at the root level timeout?: number Asynchronous loading: sets a timeout in milliseconds for the http requests. Provide it only at the root level rollbackOnError?: boolean Asynchronous loading: rollbacks to previous default locale, currency and timezone on error composedLanguage?: ISOCode[] Sets a composed language for translations missingValue?: string | ((path: string) => string) Sets the value or the function to use for missing keys. Provide it only at the root level missingKey?: string Sets the key to use for missing keys composedKeySeparator?: string Sets composed key separator i18nPlural?: boolean Disables/enables the translation of numbers that are contained at the beginning of the keys There aren't default values: you must explicitly set each parameter you need.","title":"TranslationConfig"},{"location":"spec/configuration/#dynamic-settings","text":"The configuration settings are stored in the following InjectionToken : Interface Token LocaleConfig LOCALE_CONFIG TranslationConfig TRANSLATION_CONFIG If you need to load the configuration data dynamically, you can provide a partial or empty L10nConfig in AppModule , and then update the tokens in your class: const l10nConfig: L10nConfig = { ... translation: { providers: [], // Not available here. caching: true, missingValue: 'No key' } }; @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], ... }) export class AppModule { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig ) { this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; this.l10nLoader.load(); } } Configuration must be completed before invoking the load method of L10nLoader . Or whether you use the advanced initialization : @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(TRANSLATION_CONFIG) private translationConfig: TranslationConfig ) { } load(): Promise<void> { this.translationConfig.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () => localizationConfig.load(); } @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], providers: [ ... LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], ... }) export class AppModule { }","title":"Dynamic settings"},{"location":"spec/configuration/#loading-the-translation-data","text":"","title":"Loading the translation data"},{"location":"spec/configuration/#direct-loading","text":"You can use translationData setting when you configure the service, adding all the translation data: const translationEN: any = { Title: \"Angular localization\" }; const translationIT: any = { Title: \"Localizzazione in Angular\" }; const l10nConfig: L10nConfig = { ... translation: { translationData: [ { languageCode: 'en', data: translationEN }, { languageCode: 'it', data: translationIT } ] } };","title":"Direct loading"},{"location":"spec/configuration/#asynchronous-loading-of-json-files","text":"You can add all the providers you need: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ] } }; You can use Direct and Asynchronous loading at the same time. Translation data of Direct loading will be merged before the data of Asynchronous loading.","title":"Asynchronous loading of json files"},{"location":"spec/configuration/#asynchronous-loading-through-a-web-api","text":"You can also load the data through a Web API: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.WebAPI, path: 'http://localhost:54703/api/values/' } ] } }; ... export class AppModule { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) => { if (error) { console.log(error); } }); } } [path]{languageCode} will be the URL used by the Http GET requests. So the example URI will be something like: http://localhost:54703/api/values/en .","title":"Asynchronous loading through a Web API"},{"location":"spec/configuration/#using-fallback-providers","text":"if you need a cascade fallback when the key is not found, you can use fallback providers: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Fallback, prefix: './assets/global', fallbackLanguage: [] }, { type: ProviderType.Fallback, prefix: './assets/locale-', fallbackLanguage: [ISOCode.Language] }, { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; and create the json files such as global.json , locale-en.json , locale-en-US.json . When you set a fallback provider, the translation data will be merged in order : if a key is found in the en-US file, it is used, otherwise the key in en file and finally the key in global file.","title":"Using fallback providers"},{"location":"spec/configuration/#using-a-custom-provider","text":"If you need, you can create a custom provider to load translation data. Implement TranslationProvider class-interface and the getTranslation method with the logic to retrieve the data: @Injectable() export class CustomTranslationProvider implements TranslationProvider { /** * This method must contain the logic of data access. * @param language The current language * @param args The object set during the configuration of 'providers' * @return An observable of an object of translation data: {key: value} */ public getTranslation(language: string, args: any): Observable<any> { ... return ... } } Note that the method must return an observable of an object . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationProvider: CustomTranslationProvider } ) ], ... }) See also TranslationProvider code.","title":"Using a custom provider"},{"location":"spec/configuration/#caching","text":"You can enable the cache during configuration: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true } }; The next time a translation file will be required, will be taken from the cache without making a new http request , with a significant performance improvement: if the user returns to a language already selected; if you use a global file shared across lazy loaded modules .","title":"Caching"},{"location":"spec/configuration/#error-handling-of-data-loading","text":"To find out if an error occurred during asynchronous loading of translation data, you have the translationError event: ... export class AppComponent { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) => { if (error) { console.log(error); } }); } } If the error occurs on the first loading of the application or a lazy loaded module, you can catch it with the load method: export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load() .catch(err => console.error(err)); } } If you use advanced initialization , you can catch it with the bootstrapModule method in main.ts .","title":"Error handling of data loading"},{"location":"spec/configuration/#rollback-on-errror","text":"If the error occurs when the user changes language, you can enable rollbackOnError option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... rollbackOnError: true } }; In this way, the application will keep the previous locatization without changing settings.","title":"Rollback on errror"},{"location":"spec/configuration/#using-a-composed-language","text":"By default, the languageCode is added as extension to the translation files. If you set composedLanguage during the configuration, the combination of supplied codes will be used as language: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' } }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; Your json files should be something like: ./assets/locale-en-US.json and so on. The available ISO codes are: language , country , script . Note that you have to configure defaultLocale and not only language . You must also use setDefaultLocale when the language changes.","title":"Using a composed language"},{"location":"spec/configuration/#default-locale-currency-timezone","text":"The default locale contains the current language and culture. It consists of: language code : ISO 639 two-letter or three-letter code of the language country code : ISO 3166 two-letter, uppercase code of the country and optionally: script code : used to indicate the script or writing system variations that distinguish the written forms of a language or its dialects. It consists of four letters and was defined according to the assignments found in ISO 15924 numbering system : possible values include: arab , arabext , bali , beng , deva , fullwide , gujr , guru , hanidec , khmr , knda , laoo , latn , limb , mlym , mong , mymr , orya , tamldec , telu , thai , tibt calendar : possible values include: buddhist , chinese , coptic , ethioaa , ethiopic , gregory , hebrew , indian , islamic , islamicc , iso8601 , japanese , persian , roc The currency contains the ISO 4217 currency codes. The timezone contains the time zone names of the IANA time zone database. For more information see Intl API .","title":"Default locale, currency &amp; timezone"},{"location":"spec/configuration/#storage","text":"The defaultLocale , the currency and the timezone chosen by the user are stored, and retrieved at the next access. During the configuration, you can choose your StorageStrategy : Session , Local , Cookie , Disabled . If you don't provide a different expiration using cookieExpiration , the cookie becomes a session cookie. You can also create a custom storage. Implement LocaleStorage class-interface and the read and write methods: @Injectable() export class CustomStorage implements LocaleStorage { /** * This method must contain the logic to read the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @return A promise with the value of the given name */ public async read(name: string): Promise<string | null> { ... return ... } /** * This method must contain the logic to write the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @param value The value for the given name */ public async write(name: string, value: string): Promise<void> { ... } } Note that the read method must return a promise . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { localeStorage: CustomStorage } ) ], ... }) See also LocaleStorage code.","title":"Storage"},{"location":"spec/configuration/#getting-browser-language","text":"Depending on the configuration, the library will automatically try to get the language from the browser or not: If you set language the library tries to get the language from the storage or tries to get the language from the browser or uses the language set in the configuration If you set defaultLocale the library tries to get the defaultLocale from the storage or uses the defaultLocale set in the configuration That's because not all browsers return languageCode-countryCode .","title":"Getting browser language"},{"location":"spec/configuration/#intl-api","text":"To localize dates and numbers , this library uses the Intl API . Check the current browser support: ECMAScript compatibility tables Can I use All modern browsers have implemented this API. You can use Intl.js to extend support to old browsers. Just add one script tag in your index.html : <script src=\"https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US\"></script> When specifying the features , you have to specify what locale, or locales to load. The timezone is also provided via Intl API . Except IE, all modern browsers have implemented the timezone. To extend the support, you can use Intl.DateTimeFormat timezone polyfill . When a feature is not supported, however, for example in older browsers, Angular localization does not generate an error in the browser, but returns the value without performing operations.","title":"Intl API"},{"location":"spec/configuration/#localized-routing-for-seo","text":"In locale-adaptive apps (like the apps that use this library, that return different content based on the preferred locale of the visitor), Google might not crawl, index, or rank all the content for different locales . To solve this problem, you can enable localized routing during configuration: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] }, ... }; Features: A prefix is added to the path of each navigation, containing the language or the locale, creating a semantic URL: baseHref[language[-script][-country]]path https://example.com/en/home https://example.com/en-US/home If the localized link is called, the content is automatically translated. When the language changes, the link is also updated. Changes to localized links do not change browser history. It works also with SSR. To achieve this, the router configuration in your app is not rewritten (operation that would poor performance and could cause errors): the Location class provided by Angular is used for the replacement of the URL, in order to provide the different contents localized both to the crawlers and to the users that can refer to the localized links. Since the link contains only the locale, if your app also uses numbering system , calendar , currency or timezone , you should set schema option below.","title":"Localized routing for SEO"},{"location":"spec/configuration/#using-hreflang-and-sitemap","text":"You can use the Sitemap to tell Google all of the locale variants for each URL: <?xml version=\"1.0\" encoding=\"utf-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"> <url> <loc>https://example.com/en/home</loc> <xhtml:link rel=\"alternate\" hreflang=\"it\" href=\"https://example.com/en/home\"/> <xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/it/home\"/> ... <xhtml:link rel=\"alternate\" hreflang=\"x-default\" href=\"https://example.com/home\"/> </url> <url> <loc>https://example.com/it/home</loc> ... </url> ... </urlset> For more info, visit Search Console Help - International","title":"Using hreflang and sitemap"},{"location":"spec/configuration/#options","text":"","title":"Options"},{"location":"spec/configuration/#default-routing","text":"If you don't want a localized routing for default language or locale, you can enable it during the configuration: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], localizedRoutingOptions: { defaultRouting: true } }, ... };","title":"Default routing"},{"location":"spec/configuration/#schema","text":"If your app uses numbering system , calendar , currency or timezone , it is recommended to provide the schema option, to manage the localized links and refreshes: const l10nConfig: L10nConfig = { locale: { ... localizedRouting: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], localizedRoutingOptions: { schema: [ { text: 'United States', languageCode: 'en', countryCode: 'US', currency: 'USD' }, { text: 'Italia', languageCode: 'it', countryCode: 'IT', currency: 'EUR' }, ] } }, ... };","title":"Schema"},{"location":"spec/configuration/#setting-the-locale-in-accept-language-header-on-outgoing-requests","text":"To set the locale in Accept-Language header on all outgoing requests, provide the localeInterceptor option during the configuration: const l10nConfig: L10nConfig = { locale: { ... localeInterceptor: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] }, ... }; Then import the module: @NgModule({ imports: [ ... LocaleInterceptorModule ], ... }) export class AppModule { }","title":"Setting the locale in Accept-Language header on outgoing requests"},{"location":"spec/getting-the-translation/","text":"Getting the translation \u00b6 To get the translation, this library uses pure pipes (to know the difference between pure and impure pipes see here ) or directives . You can also get the translation in component class. Pure pipes \u00b6 Pipe Type Format Pipe syntax Translate Message String expression | translate:lang L10nDate Date Date/Number/ISO string expression | l10nDate[:defaultLocale[:format[:timezone]]] L10nDecimal Decimal Number/string expression | l10nDecimal[:defaultLocale[:digitInfo]] L10nPercent Percentage Number/string expression | l10nPercent[:defaultLocale[:digitInfo]] L10nCurrency Currency Number/string expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digitInfo]]]] You can dynamically change parameters and expressions values. Messages \u00b6 Implement Language decorator in the component to provide the parameter to the translate pipe: export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. expression | translate:lang where expression is a string key that indicates the message to translate: {{ 'Title' | translate:lang }} Json : { \"Title\": \"Angular localization\" } Composed keys \u00b6 Set composedKeySeparator during the configuration, e.g. to '.' : {{ 'Home.Title' | translate:lang }} Json : { \"Home\": { \"Title\": \"Angular localization\" } } Parameters \u00b6 {{ 'User notifications' | translate:lang:{ user: username, NoMessages: messages.length } }} Json : { \"User notifications\": \"{{ user }}, you have {{ NoMessages }} new messages\" } Dates & Numbers \u00b6 Implement DefaultLocale , Currency & optionally Timezone decorators in the component to provide defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent & l10nCurrency pipes. export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Currency() currency: string; @Timezone() timezone: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Dates \u00b6 expression | l10nDate[:defaultLocale[:format[:timezone]]] Where: expression is a date object or a number (milliseconds since UTC epoch) or an ISO string. format indicates which date/time components to include. The format can be an alias as shown below: 'short' : equivalent to 'M/d/y, h:mm' (e.g. 8/29/2017, 4:37 PM for en-US ) 'medium' : equivalent to 'MMM d, y, h:mm:ss' (e.g. Aug 29, 2017, 4:32:43 PM for en-US ) 'shortDate' : equivalent to 'M/d/y' (e.g. 8/29/2017 for en-US ) 'mediumDate' : equivalent to 'MMM d, y' (e.g. Aug 29, 2017 for en-US ) 'longDate' : equivalent to 'MMMM d, y' (e.g. August 29, 2017 for en-US ) 'fullDate' : equivalent to 'EEEE, MMMM d, y' (e.g. Tuesday, August 29, 2017 for en-US ) 'shortTime' : equivalent to 'h:mm' (e.g. 4:53 PM for en-US ) 'mediumTime' : equivalent to 'h:mm:ss' (e.g. 4:54:15 PM for en-US ) It can also be an object with some or all of the following properties: weekday The representation of the weekday. Possible values are narrow , short , long . era The representation of the era. Possible values are narrow , short , long . year The representation of the year. Possible values are numeric , 2-digit . month The representation of the month. Possible values are numeric , 2-digit , narrow , short , long . day The representation of the day. Possible values are numeric , 2-digit . hour The representation of the hour. Possible values are numeric , 2-digit . minute The representation of the minute. Possible values are numeric , 2-digit . second The representation of the second. Possible values are numeric , 2-digit . timeZoneName The representation of the time zone name. Possible values are short , long . hour12 Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent. See DateTimeFormat for further information. Using format aliases \u00b6 {{ today | l10nDate:defaultLocale:'fullDate' }} Using a custom format \u00b6 @Component({ template: ` <p>{{ today | l10nDate:defaultLocale:options }}</p> ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; today: Date = new Date(); options: DateTimeOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; ngOnInit(): void { } } Using timezone \u00b6 @Component({ template: ` <p>{{ today | l10nDate:defaultLocale:'medium':timezone }}</p> ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Timezone() timezone: string; today: Date = new Date(); ngOnInit(): void { } } Decimals \u00b6 expression | l10nDecimal[:defaultLocale:[digitInfo]] where expression is a number and digitInfo has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} . {{ value | l10nDecimal:defaultLocale:'1.5-5' }} Percentages \u00b6 expression | l10nPercent[:defaultLocale:[digitInfo]] {{ value | l10nPercent:defaultLocale:'1.1-1' }} Currencies \u00b6 expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digitInfo]]]] where currencyDisplay is the currency formatting. Possible values are 'symbol' to use a localized currency symbol such as \u20ac , 'code' to use the ISO currency code, 'name' to use a localized currency name such as dollar ; the default is 'symbol' . {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }} OnPush ChangeDetectionStrategy \u00b6 Pure pipes don't need to set ChangeDetectionStrategy to OnPush . If into your components you need to use it, you have to inject ChangeDetectorRef : import { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; @Component({ ... changeDetection: ChangeDetectionStrategy.OnPush }) export class HomeComponent implements OnInit { @Language() lang: string; constructor(private cdr: ChangeDetectorRef) { } ngOnInit(): void { } } That's because we need to know the component reference that implements the OnPush strategy. Note that if you use in the component only the directives and not the pipes , you don't need to inject ChangeDetectorRef . Directives \u00b6 Directive Selectors Translate l10nTranslate , translate L10nDate l10nDate L10nDecimal l10nDecimal L10nPercent l10nPercent L10nCurrency l10nCurrency Directive Type Format Html syntax Translate Message String <tag l10n-attribute attribute=\"expr1\" [params]=\"[params]\" l10nTranslate>expr2</tag> L10nDate Date Date/Number/ISO string <tag l10n-attribute attribute=\"expr1\" format=\"[format]\" l10nDate>expr2</tag> L10nDecimal Decimal Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" l10nDecimal>expr2</tag> L10nPercent Percentage Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" l10nPercent>expr2</tag> L10nCurrency Currency Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" currencyDisplay=\"[currencyDisplay]\" l10nCurrency>expr2</tag> You can dynamically change parameters and expressions values as with pipes. How does it work? To observe the expression change (not the parameters), a MutationObserver is used: the observer is added only if detected in the browser. If you want to use this feature also reaching older browsers, we recommend using pipes. If you use in the component only the directives and not the pipes, you don't need to use decorators. Messages \u00b6 <h1 l10nTranslate>Title</h1> Parameters \u00b6 <p [params]=\"{ user: username, NoMessages: messages.length }\" l10nTranslate>User notifications</p> Dates & Numbers \u00b6 <p l10nDate>{{ today }}</p> <p format=\"fullDate\" l10nDate>{{ today }}</p> <p l10nDecimal>{{ value }}</p> <p digits=\"1.5-5\" l10nDecimal>{{ value }}</p> <p l10nPercent>{{ value }}</p> <p digits=\"1.1-1\" l10nPercent>{{ value }}</p> <p l10nCurrency>{{ value }}</p> <p digits=\"1.2-2\" currencyDisplay=\"symbol\" l10nCurrency>{{ value }}</p> Attributes \u00b6 <p l10n-title title=\"Greeting\" l10nTranslate>Title</p> All attributes will be translated according to the master directive: l10nTranslate , l10nDate and so on. You can't dynamically change expressions in attributes. Parameters \u00b6 <p l10n-title title=\"Greeting\" [params]=\"{ user: username, NoMessages: messages.length }\" l10nTranslate>User notifications</p> Json : { \"Greeting\": \"Hi {{ user }}\", \"User notifications\": \"{{ user }}, you have {{ NoMessages }} new messages\" } UI components \u00b6 You can properly translate UI components like Angular Material or Ionic: <a mat-list-item routerLinkActive=\"active-link\" routerLink=\"/home\" l10nTranslate>App.Home</a> rendered as: <a class=\"mat-list-item ng-star-inserted active-link\" l10ntranslate=\"\" mat-list-item=\"\" role=\"listitem\" routerlinkactive=\"active-link\" href=\"#/home\" style=\"\"> <div class=\"mat-list-item-content\"> <div class=\"mat-list-item-ripple mat-ripple\" mat-ripple=\"\"></div> <div class=\"mat-list-text\"></div> Home </div> </a> How does it work? The algorithm searches the text in the subtree. If there is a depth higher than 4 (in the example above the text to translate has a depth 2), we recommend using pipes. Using Html tags in translation \u00b6 If you have Html tags in translation like this: \"Strong subtitle\": \"<strong>It's a small world</strong>\" you have to use innerHTML property. Using pipes : <p [innerHTML]=\"'Strong subtitle' | translate:lang\"></p> Using directives : <p [innerHTML]=\"'Strong subtitle'\" l10nTranslate></p> Pluralization \u00b6 The library implements pluralization through the official i18nPluralPipe . Just add to it the translate pipe: <p>{{ messages.length | i18nPlural:messageMapping | translate:lang }}</p> or the directive: <p l10nTranslate>{{ messages.length | i18nPlural:messageMapping }}</p> and enable i18nPlural option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... i18nPlural: true } }; Getting the translation in component class \u00b6 Messages \u00b6 To get the translation in component class, TranslationService has the following methods: translate(keys: string | string[], args?: any, lang?: string): string | any translateAsync(keys: string | string[], args?: any, lang?: string): Observable<string | any> When you use those methods, you must be sure that the Http request is completed , and the translation file has been loaded: @Component({ ... template: ` <h1>{{ title }}</h1> <button (click)=\"getTranslation()\">Translate</button> ` }) export class HomeComponent { title: string; constructor(public translation: TranslationService) { } getTranslation(): void { this.title = this.translation.translate('Title'); } } To get the translation when the component is loaded and when the current language changes , you must subscribe to the following method: translationChanged(): Observable<string> @Component({ ... template: `<h1>{{ title }}</h1>` }) export class HomeComponent implements OnInit { title: string; constructor(public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } } Dates & numbers \u00b6 To get the translation of dates and numbers, you can use the transform method of the corresponding pipe to get the translation: you have the getDefaultLocale method of LocaleService , and the defaultLocaleChanged event to know when defaultLocale changes. @Component({ ... template: `<p>{{ value }}</p>` }) export class HomeComponent { pipe: L10nDecimalPipe = new L10nDecimalPipe(); value: any = this.pipe.transform(1234.5, this.locale.getDefaultLocale(), '1.2-2'); constructor(public locale: LocaleService) { } ngOnInit(): void { this.locale.defaultLocaleChanged.subscribe( (defaultLocale: string) => { this.value = this.pipe.transform(1234.5, defaultLocale, '1.2-2'); } ); } } Handle the translation \u00b6 The default translation handler does not perform operations on the translated values: it handles the missing keys returning the path of the key or the value set by missingValue during the configuration, and replaces parameters. To perform custom operations, you can implement TranslationHandler class-interface and the parseValue method: @Injectable() export class CustomTranslationHandler implements TranslationHandler { /** * This method must contain the logic to parse the translated value. * @param path The path of the key * @param key The key that has been requested * @param value The translated value * @param args The parameters passed along with the key * @param lang The current language * @return The parsed value */ public parseValue(path: string, key: string, value: string | null, args: any, lang: string): string { .. return ... } } Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationHandler: CustomTranslationHandler } ) ], ... }) See also TranslationHandler code. Changing language, default locale, currency or timezone at runtime \u00b6 To change language, default locale, currency or timezone at runtime, LocaleService has the following methods: setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void","title":"Getting the translation"},{"location":"spec/getting-the-translation/#getting-the-translation","text":"To get the translation, this library uses pure pipes (to know the difference between pure and impure pipes see here ) or directives . You can also get the translation in component class.","title":"Getting the translation"},{"location":"spec/getting-the-translation/#pure-pipes","text":"Pipe Type Format Pipe syntax Translate Message String expression | translate:lang L10nDate Date Date/Number/ISO string expression | l10nDate[:defaultLocale[:format[:timezone]]] L10nDecimal Decimal Number/string expression | l10nDecimal[:defaultLocale[:digitInfo]] L10nPercent Percentage Number/string expression | l10nPercent[:defaultLocale[:digitInfo]] L10nCurrency Currency Number/string expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digitInfo]]]] You can dynamically change parameters and expressions values.","title":"Pure pipes"},{"location":"spec/getting-the-translation/#messages","text":"Implement Language decorator in the component to provide the parameter to the translate pipe: export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. expression | translate:lang where expression is a string key that indicates the message to translate: {{ 'Title' | translate:lang }} Json : { \"Title\": \"Angular localization\" }","title":"Messages"},{"location":"spec/getting-the-translation/#composed-keys","text":"Set composedKeySeparator during the configuration, e.g. to '.' : {{ 'Home.Title' | translate:lang }} Json : { \"Home\": { \"Title\": \"Angular localization\" } }","title":"Composed keys"},{"location":"spec/getting-the-translation/#parameters","text":"{{ 'User notifications' | translate:lang:{ user: username, NoMessages: messages.length } }} Json : { \"User notifications\": \"{{ user }}, you have {{ NoMessages }} new messages\" }","title":"Parameters"},{"location":"spec/getting-the-translation/#dates-numbers","text":"Implement DefaultLocale , Currency & optionally Timezone decorators in the component to provide defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent & l10nCurrency pipes. export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Currency() currency: string; @Timezone() timezone: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty.","title":"Dates &amp; Numbers"},{"location":"spec/getting-the-translation/#dates","text":"expression | l10nDate[:defaultLocale[:format[:timezone]]] Where: expression is a date object or a number (milliseconds since UTC epoch) or an ISO string. format indicates which date/time components to include. The format can be an alias as shown below: 'short' : equivalent to 'M/d/y, h:mm' (e.g. 8/29/2017, 4:37 PM for en-US ) 'medium' : equivalent to 'MMM d, y, h:mm:ss' (e.g. Aug 29, 2017, 4:32:43 PM for en-US ) 'shortDate' : equivalent to 'M/d/y' (e.g. 8/29/2017 for en-US ) 'mediumDate' : equivalent to 'MMM d, y' (e.g. Aug 29, 2017 for en-US ) 'longDate' : equivalent to 'MMMM d, y' (e.g. August 29, 2017 for en-US ) 'fullDate' : equivalent to 'EEEE, MMMM d, y' (e.g. Tuesday, August 29, 2017 for en-US ) 'shortTime' : equivalent to 'h:mm' (e.g. 4:53 PM for en-US ) 'mediumTime' : equivalent to 'h:mm:ss' (e.g. 4:54:15 PM for en-US ) It can also be an object with some or all of the following properties: weekday The representation of the weekday. Possible values are narrow , short , long . era The representation of the era. Possible values are narrow , short , long . year The representation of the year. Possible values are numeric , 2-digit . month The representation of the month. Possible values are numeric , 2-digit , narrow , short , long . day The representation of the day. Possible values are numeric , 2-digit . hour The representation of the hour. Possible values are numeric , 2-digit . minute The representation of the minute. Possible values are numeric , 2-digit . second The representation of the second. Possible values are numeric , 2-digit . timeZoneName The representation of the time zone name. Possible values are short , long . hour12 Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent. See DateTimeFormat for further information.","title":"Dates"},{"location":"spec/getting-the-translation/#using-format-aliases","text":"{{ today | l10nDate:defaultLocale:'fullDate' }}","title":"Using format aliases"},{"location":"spec/getting-the-translation/#using-a-custom-format","text":"@Component({ template: ` <p>{{ today | l10nDate:defaultLocale:options }}</p> ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; today: Date = new Date(); options: DateTimeOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; ngOnInit(): void { } }","title":"Using a custom format"},{"location":"spec/getting-the-translation/#using-timezone","text":"@Component({ template: ` <p>{{ today | l10nDate:defaultLocale:'medium':timezone }}</p> ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Timezone() timezone: string; today: Date = new Date(); ngOnInit(): void { } }","title":"Using timezone"},{"location":"spec/getting-the-translation/#decimals","text":"expression | l10nDecimal[:defaultLocale:[digitInfo]] where expression is a number and digitInfo has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} . {{ value | l10nDecimal:defaultLocale:'1.5-5' }}","title":"Decimals"},{"location":"spec/getting-the-translation/#percentages","text":"expression | l10nPercent[:defaultLocale:[digitInfo]] {{ value | l10nPercent:defaultLocale:'1.1-1' }}","title":"Percentages"},{"location":"spec/getting-the-translation/#currencies","text":"expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digitInfo]]]] where currencyDisplay is the currency formatting. Possible values are 'symbol' to use a localized currency symbol such as \u20ac , 'code' to use the ISO currency code, 'name' to use a localized currency name such as dollar ; the default is 'symbol' . {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }}","title":"Currencies"},{"location":"spec/getting-the-translation/#onpush-changedetectionstrategy","text":"Pure pipes don't need to set ChangeDetectionStrategy to OnPush . If into your components you need to use it, you have to inject ChangeDetectorRef : import { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'; @Component({ ... changeDetection: ChangeDetectionStrategy.OnPush }) export class HomeComponent implements OnInit { @Language() lang: string; constructor(private cdr: ChangeDetectorRef) { } ngOnInit(): void { } } That's because we need to know the component reference that implements the OnPush strategy. Note that if you use in the component only the directives and not the pipes , you don't need to inject ChangeDetectorRef .","title":"OnPush ChangeDetectionStrategy"},{"location":"spec/getting-the-translation/#directives","text":"Directive Selectors Translate l10nTranslate , translate L10nDate l10nDate L10nDecimal l10nDecimal L10nPercent l10nPercent L10nCurrency l10nCurrency Directive Type Format Html syntax Translate Message String <tag l10n-attribute attribute=\"expr1\" [params]=\"[params]\" l10nTranslate>expr2</tag> L10nDate Date Date/Number/ISO string <tag l10n-attribute attribute=\"expr1\" format=\"[format]\" l10nDate>expr2</tag> L10nDecimal Decimal Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" l10nDecimal>expr2</tag> L10nPercent Percentage Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" l10nPercent>expr2</tag> L10nCurrency Currency Number/string <tag l10n-attribute attribute=\"expr1\" digits=\"[digitInfo]\" currencyDisplay=\"[currencyDisplay]\" l10nCurrency>expr2</tag> You can dynamically change parameters and expressions values as with pipes. How does it work? To observe the expression change (not the parameters), a MutationObserver is used: the observer is added only if detected in the browser. If you want to use this feature also reaching older browsers, we recommend using pipes. If you use in the component only the directives and not the pipes, you don't need to use decorators.","title":"Directives"},{"location":"spec/getting-the-translation/#messages_1","text":"<h1 l10nTranslate>Title</h1>","title":"Messages"},{"location":"spec/getting-the-translation/#parameters_1","text":"<p [params]=\"{ user: username, NoMessages: messages.length }\" l10nTranslate>User notifications</p>","title":"Parameters"},{"location":"spec/getting-the-translation/#dates-numbers_1","text":"<p l10nDate>{{ today }}</p> <p format=\"fullDate\" l10nDate>{{ today }}</p> <p l10nDecimal>{{ value }}</p> <p digits=\"1.5-5\" l10nDecimal>{{ value }}</p> <p l10nPercent>{{ value }}</p> <p digits=\"1.1-1\" l10nPercent>{{ value }}</p> <p l10nCurrency>{{ value }}</p> <p digits=\"1.2-2\" currencyDisplay=\"symbol\" l10nCurrency>{{ value }}</p>","title":"Dates &amp; Numbers"},{"location":"spec/getting-the-translation/#attributes","text":"<p l10n-title title=\"Greeting\" l10nTranslate>Title</p> All attributes will be translated according to the master directive: l10nTranslate , l10nDate and so on. You can't dynamically change expressions in attributes.","title":"Attributes"},{"location":"spec/getting-the-translation/#parameters_2","text":"<p l10n-title title=\"Greeting\" [params]=\"{ user: username, NoMessages: messages.length }\" l10nTranslate>User notifications</p> Json : { \"Greeting\": \"Hi {{ user }}\", \"User notifications\": \"{{ user }}, you have {{ NoMessages }} new messages\" }","title":"Parameters"},{"location":"spec/getting-the-translation/#ui-components","text":"You can properly translate UI components like Angular Material or Ionic: <a mat-list-item routerLinkActive=\"active-link\" routerLink=\"/home\" l10nTranslate>App.Home</a> rendered as: <a class=\"mat-list-item ng-star-inserted active-link\" l10ntranslate=\"\" mat-list-item=\"\" role=\"listitem\" routerlinkactive=\"active-link\" href=\"#/home\" style=\"\"> <div class=\"mat-list-item-content\"> <div class=\"mat-list-item-ripple mat-ripple\" mat-ripple=\"\"></div> <div class=\"mat-list-text\"></div> Home </div> </a> How does it work? The algorithm searches the text in the subtree. If there is a depth higher than 4 (in the example above the text to translate has a depth 2), we recommend using pipes.","title":"UI components"},{"location":"spec/getting-the-translation/#using-html-tags-in-translation","text":"If you have Html tags in translation like this: \"Strong subtitle\": \"<strong>It's a small world</strong>\" you have to use innerHTML property. Using pipes : <p [innerHTML]=\"'Strong subtitle' | translate:lang\"></p> Using directives : <p [innerHTML]=\"'Strong subtitle'\" l10nTranslate></p>","title":"Using Html tags in translation"},{"location":"spec/getting-the-translation/#pluralization","text":"The library implements pluralization through the official i18nPluralPipe . Just add to it the translate pipe: <p>{{ messages.length | i18nPlural:messageMapping | translate:lang }}</p> or the directive: <p l10nTranslate>{{ messages.length | i18nPlural:messageMapping }}</p> and enable i18nPlural option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... i18nPlural: true } };","title":"Pluralization"},{"location":"spec/getting-the-translation/#getting-the-translation-in-component-class","text":"","title":"Getting the translation in component class"},{"location":"spec/getting-the-translation/#messages_2","text":"To get the translation in component class, TranslationService has the following methods: translate(keys: string | string[], args?: any, lang?: string): string | any translateAsync(keys: string | string[], args?: any, lang?: string): Observable<string | any> When you use those methods, you must be sure that the Http request is completed , and the translation file has been loaded: @Component({ ... template: ` <h1>{{ title }}</h1> <button (click)=\"getTranslation()\">Translate</button> ` }) export class HomeComponent { title: string; constructor(public translation: TranslationService) { } getTranslation(): void { this.title = this.translation.translate('Title'); } } To get the translation when the component is loaded and when the current language changes , you must subscribe to the following method: translationChanged(): Observable<string> @Component({ ... template: `<h1>{{ title }}</h1>` }) export class HomeComponent implements OnInit { title: string; constructor(public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () => { this.title = this.translation.translate('Title'); } ); } }","title":"Messages"},{"location":"spec/getting-the-translation/#dates-numbers_2","text":"To get the translation of dates and numbers, you can use the transform method of the corresponding pipe to get the translation: you have the getDefaultLocale method of LocaleService , and the defaultLocaleChanged event to know when defaultLocale changes. @Component({ ... template: `<p>{{ value }}</p>` }) export class HomeComponent { pipe: L10nDecimalPipe = new L10nDecimalPipe(); value: any = this.pipe.transform(1234.5, this.locale.getDefaultLocale(), '1.2-2'); constructor(public locale: LocaleService) { } ngOnInit(): void { this.locale.defaultLocaleChanged.subscribe( (defaultLocale: string) => { this.value = this.pipe.transform(1234.5, defaultLocale, '1.2-2'); } ); } }","title":"Dates &amp; numbers"},{"location":"spec/getting-the-translation/#handle-the-translation","text":"The default translation handler does not perform operations on the translated values: it handles the missing keys returning the path of the key or the value set by missingValue during the configuration, and replaces parameters. To perform custom operations, you can implement TranslationHandler class-interface and the parseValue method: @Injectable() export class CustomTranslationHandler implements TranslationHandler { /** * This method must contain the logic to parse the translated value. * @param path The path of the key * @param key The key that has been requested * @param value The translated value * @param args The parameters passed along with the key * @param lang The current language * @return The parsed value */ public parseValue(path: string, key: string, value: string | null, args: any, lang: string): string { .. return ... } } Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationHandler: CustomTranslationHandler } ) ], ... }) See also TranslationHandler code.","title":"Handle the translation"},{"location":"spec/getting-the-translation/#changing-language-default-locale-currency-or-timezone-at-runtime","text":"To change language, default locale, currency or timezone at runtime, LocaleService has the following methods: setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void","title":"Changing language, default locale, currency or timezone at runtime"},{"location":"spec/lazy-loading/","text":"Lazy loaded modules & Shared modules \u00b6 Before you start using this configuration, you need to know how lazy-loading works: Lazy-loading modules with the router . Lazy loaded modules with the router \u00b6 You can create an instance of TranslationService with its own translation data for every lazy loaded module, as shown: You can create a new instance of TranslationService calling the forChild method of the module you are using, and configure the service with the new providers: const l10nConfig: L10nConfig = { translation: { providers: [ { type: ProviderType.Static, prefix: './src/assets/locale-' }, { type: ProviderType.Static, prefix: './src/assets/locale-list-' } ], ... } }; @NgModule({ imports: [ ... TranslationModule.forChild(l10nConfig) // New instance of TranslationService. ], declarations: [ListComponent] }) export class ListModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } If you use a global file shared across lazy loaded modules , you can enable the caching during the configuration in AppModule . In this way, application performance and memory usage are optimized. Shared modules \u00b6 If you don't want a new instance of TranslationService with its own translation data for each feature module, but you want it to be singleton and shared by other modules, you have to call forRoot method of the module you are using once in AppModule : @NgModule({ imports: [ ... SharedModule, TranslationModule.forRoot(l10nConfig) ], ... }) export class AppModule { } Import/export TranslationModule or LocalizationModule without methods in a shared module: const sharedModules: any[] = [ ... TranslationModule ]; @NgModule({ imports: sharedModules, exports: sharedModules }) export class SharedModule { } Then in the feature module (also if it is lazy loaded ): @NgModule({ imports: [ ... SharedModule ], ... }) export class ListModule { } You must provide the configuration only in AppModule .","title":"Lazy loaded modules & Shared modules"},{"location":"spec/lazy-loading/#lazy-loaded-modules-shared-modules","text":"Before you start using this configuration, you need to know how lazy-loading works: Lazy-loading modules with the router .","title":"Lazy loaded modules &amp; Shared modules"},{"location":"spec/lazy-loading/#lazy-loaded-modules-with-the-router","text":"You can create an instance of TranslationService with its own translation data for every lazy loaded module, as shown: You can create a new instance of TranslationService calling the forChild method of the module you are using, and configure the service with the new providers: const l10nConfig: L10nConfig = { translation: { providers: [ { type: ProviderType.Static, prefix: './src/assets/locale-' }, { type: ProviderType.Static, prefix: './src/assets/locale-list-' } ], ... } }; @NgModule({ imports: [ ... TranslationModule.forChild(l10nConfig) // New instance of TranslationService. ], declarations: [ListComponent] }) export class ListModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } If you use a global file shared across lazy loaded modules , you can enable the caching during the configuration in AppModule . In this way, application performance and memory usage are optimized.","title":"Lazy loaded modules with the router"},{"location":"spec/lazy-loading/#shared-modules","text":"If you don't want a new instance of TranslationService with its own translation data for each feature module, but you want it to be singleton and shared by other modules, you have to call forRoot method of the module you are using once in AppModule : @NgModule({ imports: [ ... SharedModule, TranslationModule.forRoot(l10nConfig) ], ... }) export class AppModule { } Import/export TranslationModule or LocalizationModule without methods in a shared module: const sharedModules: any[] = [ ... TranslationModule ]; @NgModule({ imports: sharedModules, exports: sharedModules }) export class SharedModule { } Then in the feature module (also if it is lazy loaded ): @NgModule({ imports: [ ... SharedModule ], ... }) export class ListModule { } You must provide the configuration only in AppModule .","title":"Shared modules"},{"location":"spec/library-structure/","text":"Library structure \u00b6 Main modules \u00b6 Class Contract TranslationModule Provides dependencies, pipes & directives for translating messages LocalizationModule Provides dependencies, pipes & directives for translating messages, dates & numbers LocaleValidationModule Provides dependencies & directives for locale validation CollatorModule Provides dependencies for sorting and filtering a list by locales LocaleInterceptorModule Sets locale in Accept-Language header on outgoing requests Main services \u00b6 Class Contract L10nLoader Initializes the services LocaleService Manages language, default locale, currency & timezone TranslationService Manages the translation data LocaleValidation Provides the methods for locale validation Collator Intl.Collator APIs IntlAPI Provides the methods to check if Intl APIs are supported Main class-interfaces \u00b6 Class Contract LocaleStorage Class-interface to create a custom storage for default locale, currency & timezone TranslationProvider Class-interface to create a custom provider for translation data TranslationHandler Class-interface to create a custom handler for translated values","title":"Library structure"},{"location":"spec/library-structure/#library-structure","text":"","title":"Library structure"},{"location":"spec/library-structure/#main-modules","text":"Class Contract TranslationModule Provides dependencies, pipes & directives for translating messages LocalizationModule Provides dependencies, pipes & directives for translating messages, dates & numbers LocaleValidationModule Provides dependencies & directives for locale validation CollatorModule Provides dependencies for sorting and filtering a list by locales LocaleInterceptorModule Sets locale in Accept-Language header on outgoing requests","title":"Main modules"},{"location":"spec/library-structure/#main-services","text":"Class Contract L10nLoader Initializes the services LocaleService Manages language, default locale, currency & timezone TranslationService Manages the translation data LocaleValidation Provides the methods for locale validation Collator Intl.Collator APIs IntlAPI Provides the methods to check if Intl APIs are supported","title":"Main services"},{"location":"spec/library-structure/#main-class-interfaces","text":"Class Contract LocaleStorage Class-interface to create a custom storage for default locale, currency & timezone TranslationProvider Class-interface to create a custom provider for translation data TranslationHandler Class-interface to create a custom handler for translated values","title":"Main class-interfaces"},{"location":"spec/testing/","text":"Unit testing \u00b6 There are several ways to test an app that implements this library. To provide the data, you could use: a MockBackend real services mock services During the configuration of Jasmine , you could do something like this: describe('Component: HomeComponent', () => { let fixture: ComponentFixture<HomeComponent>; let comp: HomeComponent; let l10nLoader: L10nLoader; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Disabled }, translation: { providers: [ { type: ProviderType.Static, prefix: '/assets/locale-' } ], ... } }; beforeEach(async () => { TestBed.configureTestingModule({ imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [HomeComponent] }).compileComponents(); fixture = TestBed.createComponent(HomeComponent); comp = fixture.componentInstance; }); beforeEach((done: any) => { l10nLoader = TestBed.get(L10nLoader); l10nLoader.load().then(() => done()); }); it('should render translated text', (() => { fixture.detectChanges(); expect(...); })); }); In this case the real services are injected, importing LocalizationModule.forRoot method. The loading of configuration is in a dedicated beforeEach , that will be released only when the promise of the load method of L10nLoader will be resolved.","title":"Unit testing"},{"location":"spec/testing/#unit-testing","text":"There are several ways to test an app that implements this library. To provide the data, you could use: a MockBackend real services mock services During the configuration of Jasmine , you could do something like this: describe('Component: HomeComponent', () => { let fixture: ComponentFixture<HomeComponent>; let comp: HomeComponent; let l10nLoader: L10nLoader; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Disabled }, translation: { providers: [ { type: ProviderType.Static, prefix: '/assets/locale-' } ], ... } }; beforeEach(async () => { TestBed.configureTestingModule({ imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [HomeComponent] }).compileComponents(); fixture = TestBed.createComponent(HomeComponent); comp = fixture.componentInstance; }); beforeEach((done: any) => { l10nLoader = TestBed.get(L10nLoader); l10nLoader.load().then(() => done()); }); it('should render translated text', (() => { fixture.detectChanges(); expect(...); })); }); In this case the real services are injected, importing LocalizationModule.forRoot method. The loading of configuration is in a dedicated beforeEach , that will be released only when the promise of the load method of L10nLoader will be resolved.","title":"Unit testing"},{"location":"spec/validation/","text":"Validation by locales \u00b6 Import the modules you need in the application root module: @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig), LocaleValidationModule.forRoot() ], declarations: [AppComponent], bootstrap: [AppComponent] }) export class AppModule { } Validating a number \u00b6 Directive Selectors L10nNumberValidator l10nValidateNumber Directive Validator Options Errors L10nNumberValidator digits=[digitInfo] [minValue] [maxValue] format or minValue or maxValue where digitInfo has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} , and minValue and maxValue attributes are optional: <input digits=\"1.2-2\" minValue=\"0\" maxValue=\"1000\" name=\"decimal\" [(ngModel)]=\"decimal\" l10nValidateNumber> or, if you use variables: <input [digits]=\"digits\" [minValue]=\"minValue\" [maxValue]=\"maxValue\" name=\"decimal\" [(ngModel)]=\"decimal\" l10nValidateNumber> The number can be entered with or without the thousands separator. Parsing a number \u00b6 When the number is valid, you can get its value by the parseNumber method of LocaleValidation : parsedValue: number = null; constructor(private localeValidation: LocaleValidation) { } onSubmit(value: string): void { this.parsedValue = this.localeValidation.parseNumber(value); } FormBuilder \u00b6 If you use FormBuilder , you have to invoke the following function: l10nValidateNumber(digits: string, MIN_VALUE?: number, MAX_VALUE?: number): Function","title":"Validation by locales"},{"location":"spec/validation/#validation-by-locales","text":"Import the modules you need in the application root module: @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig), LocaleValidationModule.forRoot() ], declarations: [AppComponent], bootstrap: [AppComponent] }) export class AppModule { }","title":"Validation by locales"},{"location":"spec/validation/#validating-a-number","text":"Directive Selectors L10nNumberValidator l10nValidateNumber Directive Validator Options Errors L10nNumberValidator digits=[digitInfo] [minValue] [maxValue] format or minValue or maxValue where digitInfo has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} , and minValue and maxValue attributes are optional: <input digits=\"1.2-2\" minValue=\"0\" maxValue=\"1000\" name=\"decimal\" [(ngModel)]=\"decimal\" l10nValidateNumber> or, if you use variables: <input [digits]=\"digits\" [minValue]=\"minValue\" [maxValue]=\"maxValue\" name=\"decimal\" [(ngModel)]=\"decimal\" l10nValidateNumber> The number can be entered with or without the thousands separator.","title":"Validating a number"},{"location":"spec/validation/#parsing-a-number","text":"When the number is valid, you can get its value by the parseNumber method of LocaleValidation : parsedValue: number = null; constructor(private localeValidation: LocaleValidation) { } onSubmit(value: string): void { this.parsedValue = this.localeValidation.parseNumber(value); }","title":"Parsing a number"},{"location":"spec/validation/#formbuilder","text":"If you use FormBuilder , you have to invoke the following function: l10nValidateNumber(digits: string, MIN_VALUE?: number, MAX_VALUE?: number): Function","title":"FormBuilder"}]}